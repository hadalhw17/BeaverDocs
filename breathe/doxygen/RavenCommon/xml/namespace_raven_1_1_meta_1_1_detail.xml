<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespace_raven_1_1_meta_1_1_detail" kind="namespace" language="C++">
    <compoundname>Raven::Meta::Detail</compoundname>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_sequential_container_binder" prot="public">Raven::Meta::Detail::SequentialContainerBinder</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_associative_container_binder" prot="public">Raven::Meta::Detail::AssociativeContainerBinder</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_has_is_valid_alias" prot="public">Raven::Meta::Detail::HasIsValidAlias</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_template_argument_extractor" prot="public">Raven::Meta::Detail::TemplateArgumentExtractor</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_template_argument_extractor_3_01_t_3_01_args_8_8_8_01_4_01_4" prot="public">Raven::Meta::Detail::TemplateArgumentExtractor&lt; T&lt; Args... &gt; &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_wrapper_type_meta" prot="public">Raven::Meta::Detail::WrapperTypeMeta</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_wrapper_type_meta_3_01_t_00_01false_01_4" prot="public">Raven::Meta::Detail::WrapperTypeMeta&lt; T, false &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_create_variant_policy" prot="public">Raven::Meta::Detail::CreateVariantPolicy</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_create_empty_variant_policy" prot="public">Raven::Meta::Detail::CreateEmptyVariantPolicy</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from" prot="public">Raven::Meta::Detail::CastFrom</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_empty_caster" prot="public">Raven::Meta::Detail::EmptyCaster</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_default_caster" prot="public">Raven::Meta::Detail::DefaultCaster</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_3_01bool_01_4" prot="public">Raven::Meta::Detail::CastFrom&lt; bool &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_3_01char_01_4" prot="public">Raven::Meta::Detail::CastFrom&lt; char &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1int8__t_01_4" prot="public">Raven::Meta::Detail::CastFrom&lt; std::int8_t &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1uint8__t_01_4" prot="public">Raven::Meta::Detail::CastFrom&lt; std::uint8_t &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1int16__t_01_4" prot="public">Raven::Meta::Detail::CastFrom&lt; std::int16_t &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1uint16__t_01_4" prot="public">Raven::Meta::Detail::CastFrom&lt; std::uint16_t &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1int32__t_01_4" prot="public">Raven::Meta::Detail::CastFrom&lt; std::int32_t &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1uint32__t_01_4" prot="public">Raven::Meta::Detail::CastFrom&lt; std::uint32_t &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1int64__t_01_4" prot="public">Raven::Meta::Detail::CastFrom&lt; std::int64_t &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1uint64__t_01_4" prot="public">Raven::Meta::Detail::CastFrom&lt; std::uint64_t &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_3_01float_01_4" prot="public">Raven::Meta::Detail::CastFrom&lt; float &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_3_01double_01_4" prot="public">Raven::Meta::Detail::CastFrom&lt; double &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1string_01_4" prot="public">Raven::Meta::Detail::CastFrom&lt; std::string &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_enum" prot="public">Raven::Meta::Detail::CastFromEnum</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_sequential_container_binder_dynamic" prot="public">Raven::Meta::Detail::SequentialContainerBinderDynamic</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_sequential_container_binder_direct_access" prot="public">Raven::Meta::Detail::SequentialContainerBinderDirectAccess</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_sequential_container_binder_3_01std_1_1vector_3_01_t_01_4_01_4" prot="public">Raven::Meta::Detail::SequentialContainerBinder&lt; std::vector&lt; T &gt; &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_sequential_container_binder_wrapper" prot="public">Raven::Meta::Detail::SequentialContainerBinderWrapper</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_associative_container_value" prot="public">Raven::Meta::Detail::AssociativeContainerValue</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_associative_container_binder_base" prot="public">Raven::Meta::Detail::AssociativeContainerBinderBase</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_associative_container_binder_base_map" prot="public">Raven::Meta::Detail::AssociativeContainerBinderBaseMap</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_associative_container_binder_base_set" prot="public">Raven::Meta::Detail::AssociativeContainerBinderBaseSet</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_associative_container_binder_3_01std_1_1unordered__set_3_01_t_01_4_01_4" prot="public">Raven::Meta::Detail::AssociativeContainerBinder&lt; std::unordered_set&lt; T &gt; &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_associative_container_binder_3_01std_1_1unordered__map_3_01_t_00_01_u_01_4_01_4" prot="public">Raven::Meta::Detail::AssociativeContainerBinder&lt; std::unordered_map&lt; T, U &gt; &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_associative_container_binder_3_01std_1_1set_3_01_t_01_4_01_4" prot="public">Raven::Meta::Detail::AssociativeContainerBinder&lt; std::set&lt; T &gt; &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_associative_container_binder_3_01std_1_1map_3_01_t_00_01_u_01_4_01_4" prot="public">Raven::Meta::Detail::AssociativeContainerBinder&lt; std::map&lt; T, U &gt; &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_associative_container_binder_wrapper" prot="public">Raven::Meta::Detail::AssociativeContainerBinderWrapper</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_prop__" prot="public">Raven::Meta::Detail::Prop_</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_enum__" prot="public">Raven::Meta::Detail::Enum_</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_remove_all_pointers" prot="public">Raven::Meta::Detail::RemoveAllPointers</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_remove_all_pointers_3_01_t_00_01std_1_1enable__if__t_3_01st1a25f438b78ace944fc75ab7fd0345e2" prot="public">Raven::Meta::Detail::RemoveAllPointers&lt; T, std::enable_if_t&lt; std::is_pointer_v&lt; T &gt; &gt; &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_remove_all_pointers_except_one" prot="public">Raven::Meta::Detail::RemoveAllPointersExceptOne</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_remove_all_pointers_except_one_3_01_t_00_01std_1_1enable__id3e35a21fcae306ea371e1c556c0d356" prot="public">Raven::Meta::Detail::RemoveAllPointersExceptOne&lt; T, std::enable_if_t&lt; std::is_pointer_v&lt; T &gt; &gt; &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_raw_type" prot="public">Raven::Meta::Detail::RawType</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_raw_type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pofb09200826997ff9fbd13d333529444e" prot="public">Raven::Meta::Detail::RawType&lt; T, std::enable_if_t&lt; std::is_pointer_v&lt; T &gt; &amp;&amp;!IsFunctionPtr&lt; T &gt;::value &gt; &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_raw_type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__re7128857a343ae1ccf81f5fa2b61b7ace" prot="public">Raven::Meta::Detail::RawType&lt; T, std::enable_if_t&lt; std::is_reference_v&lt; T &gt; &amp;&amp;!IsFunctionPtr&lt; T &gt;::value &gt; &gt;</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_raw_address_of_impl" prot="public">Raven::Meta::Detail::RawAddressOfImpl</innerclass>
    <innerclass refid="struct_raven_1_1_meta_1_1_detail_1_1_invalid_wrapped_type" prot="public">Raven::Meta::Detail::InvalidWrappedType</innerclass>
    <innerclass refid="class_raven_1_1_meta_1_1_detail_1_1_enum_data" prot="public">Raven::Meta::Detail::EnumData</innerclass>
    <innerclass refid="class_raven_1_1_meta_1_1_detail_1_1_enum_wrapper_base" prot="public">Raven::Meta::Detail::EnumWrapperBase</innerclass>
    <innerclass refid="class_raven_1_1_meta_1_1_detail_1_1_enum_wrapper" prot="public">Raven::Meta::Detail::EnumWrapper</innerclass>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="_property_traits_8hpp_1acd09e094be387eeb64181ec01c1532de" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Tp</type>
            <defval>std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::integral_constant&lt; bool, !<ref refid="struct_raven_1_1_meta_1_1_detail_1_1_has_is_valid_alias" kindref="compound">HasIsValidAlias</ref>&lt; <ref refid="struct_raven_1_1_meta_1_1_detail_1_1_sequential_container_binder" kindref="compound">SequentialContainerBinder</ref>&lt; Tp &gt; &gt;::Value &gt;</type>
        <definition>using Raven::Meta::Detail::IsSequentialContainer = typedef std::integral_constant&lt;bool, !HasIsValidAlias&lt;SequentialContainerBinder&lt;Tp&gt; &gt;::Value&gt;</definition>
        <argsstring></argsstring>
        <name>IsSequentialContainer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/PropertyTraits.hpp" line="32" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/PropertyTraits.hpp" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_property_traits_8hpp_1aad5ad99339588af95c72d63ec99b7fe7" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Tp</type>
            <defval>std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::integral_constant&lt; bool, !<ref refid="struct_raven_1_1_meta_1_1_detail_1_1_has_is_valid_alias" kindref="compound">HasIsValidAlias</ref>&lt; <ref refid="struct_raven_1_1_meta_1_1_detail_1_1_associative_container_binder" kindref="compound">AssociativeContainerBinder</ref>&lt; Tp &gt; &gt;::Value &gt;</type>
        <definition>using Raven::Meta::Detail::IsAssociativeContainer = typedef std::integral_constant&lt;bool, !HasIsValidAlias&lt;AssociativeContainerBinder&lt;Tp&gt; &gt;::Value&gt;</definition>
        <argsstring></argsstring>
        <name>IsAssociativeContainer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/PropertyTraits.hpp" line="35" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/PropertyTraits.hpp" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_type_desc_8hpp_1a01172599e50eaf74e1dbe1a04b940a14" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename std::conditional_t&lt; std::is_abstract_v&lt; T &gt;||!std::is_default_constructible_v&lt; T &gt;||!std::is_copy_constructible_v&lt; T &gt;, <ref refid="struct_raven_1_1_meta_1_1_detail_1_1_create_empty_variant_policy" kindref="compound">CreateEmptyVariantPolicy</ref>, <ref refid="struct_raven_1_1_meta_1_1_detail_1_1_create_variant_policy" kindref="compound">CreateVariantPolicy</ref>&lt; T &gt; &gt;</type>
        <definition>using Raven::Meta::Detail::CreateVariantPolicyT = typedef typename std::conditional_t&lt;std::is_abstract_v&lt;T&gt; || !std::is_default_constructible_v&lt;T&gt; || !std::is_copy_constructible_v&lt;T&gt;, CreateEmptyVariantPolicy, CreateVariantPolicy&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>CreateVariantPolicyT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeDesc.hpp" line="164" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeDesc.hpp" bodystart="164" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_type_casting_8hpp_1a7fd7334820e4a52e9ded07c9493e0e59" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename A</type>
          </param>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::integral_constant&lt; bool, !std::is_same_v&lt; A, B &gt; &amp;&amp;std::is_integral_v&lt; A &gt; &amp;&amp;std::is_integral_v&lt; B &gt; &gt;</type>
        <definition>using Raven::Meta::Detail::AreIntegrals = typedef std::integral_constant&lt;bool, !std::is_same_v&lt;A, B&gt; &amp;&amp; std::is_integral_v&lt;A&gt; &amp;&amp; std::is_integral_v&lt;B&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>AreIntegrals</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="76" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="77" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_variant_policy_8hpp_1a7093cabf1b12a5f3f3365531c6a247ad" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="struct_raven_1_1_meta_1_1_detail_1_1_default_caster" kindref="compound">DefaultCaster</ref>&lt; T, <ref refid="struct_raven_1_1_meta_1_1_detail_1_1_cast_from_enum" kindref="compound">CastFromEnum</ref>&lt; T &gt; &gt;</type>
        <definition>using Raven::Meta::Detail::EnumCaster = typedef DefaultCaster&lt;T, CastFromEnum&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>EnumCaster</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" line="22" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" bodystart="22" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_iterator_binder_8hpp_1a9a044ca3b3bb33301720b149e553f618" prot="public" static="no">
        <type>std::byte[sizeof(double)]</type>
        <definition>using Raven::Meta::Detail::IteratorData = typedef std::byte[sizeof(double)]</definition>
        <argsstring></argsstring>
        <name>IteratorData</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/IteratorBinder.hpp" line="9" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/IteratorBinder.hpp" bodystart="9" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_meta_2_utils_8hpp_1a5e0fa33ff71438496e642121f79160c7" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="struct_raven_1_1_meta_1_1_detail_1_1_remove_all_pointers" kindref="compound">RemoveAllPointers</ref>&lt; T &gt;::<ref refid="class_raven_1_1_meta_1_1_type" kindref="compound">Type</ref></type>
        <definition>using Raven::Meta::Detail::RemoveAllPointersT = typedef typename RemoveAllPointers&lt;T&gt;::Type</definition>
        <argsstring></argsstring>
        <name>RemoveAllPointersT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" line="22" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" bodystart="22" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_meta_2_utils_8hpp_1a4de33ef0c98dd1e3ff834292c15fffd1" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="struct_raven_1_1_meta_1_1_detail_1_1_remove_all_pointers_except_one" kindref="compound">RemoveAllPointersExceptOne</ref>&lt; T &gt;::<ref refid="class_raven_1_1_meta_1_1_type" kindref="compound">Type</ref></type>
        <definition>using Raven::Meta::Detail::RemoveAllPointersExceptOneT = typedef typename RemoveAllPointersExceptOne&lt;T&gt;::Type</definition>
        <argsstring></argsstring>
        <name>RemoveAllPointersExceptOneT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" line="37" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" bodystart="37" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_meta_2_utils_8hpp_1ab477c2f35fd8b92a13acd2b706084f64" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::integral_constant&lt; bool, std::is_pointer_v&lt; T &gt; &amp;&amp;std::is_function_v&lt; std::remove_pointer_t&lt; T &gt; &gt;&gt;</type>
        <definition>using Raven::Meta::Detail::IsFunctionPtr = typedef std::integral_constant&lt;bool, std::is_pointer_v&lt;T&gt; &amp;&amp; std::is_function_v&lt;std::remove_pointer_t&lt;T&gt; &gt;&gt;</definition>
        <argsstring></argsstring>
        <name>IsFunctionPtr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" line="40" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_meta_2_utils_8hpp_1a9a6499f77fc38e2f0093cb274fc1526e" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="struct_raven_1_1_meta_1_1_detail_1_1_raw_type" kindref="compound">RawType</ref>&lt; T &gt;::<ref refid="class_raven_1_1_meta_1_1_type" kindref="compound">Type</ref></type>
        <definition>using Raven::Meta::Detail::RawTypeT = typedef typename RawType&lt;T&gt;::Type</definition>
        <argsstring></argsstring>
        <name>RawTypeT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" line="61" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" bodystart="61" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_meta_2_utils_8hpp_1a0c077a39e0441e9b6fd642af065b2f99" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename std::add_pointer_t&lt; <ref refid="struct_raven_1_1_meta_1_1_detail_1_1_remove_all_pointers" kindref="compound">RemoveAllPointers</ref>&lt; T &gt; &gt;</type>
        <definition>using Raven::Meta::Detail::NormalReturnT = typedef typename std::add_pointer_t&lt;RemoveAllPointers&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>NormalReturnT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" line="64" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" bodystart="64" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_meta_2_utils_8hpp_1a0b393dae007f3991ba8c4ecb232b5393" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Tp</type>
            <defval>std::remove_reference_t&lt;T&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::conditional_t&lt; IsFunctionPtr&lt; RemoveAllPointersExceptOneT&lt; Tp &gt; &gt;::value, std::add_pointer_t&lt; RemoveAllPointersExceptOneT&lt; Tp &gt; &gt;, NormalReturnT&lt; Tp &gt; &gt;</type>
        <definition>using Raven::Meta::Detail::RawAddressofReturnType = typedef std::conditional_t&lt;IsFunctionPtr&lt;RemoveAllPointersExceptOneT&lt;Tp&gt; &gt;::value, std::add_pointer_t&lt;RemoveAllPointersExceptOneT&lt;Tp&gt; &gt;, NormalReturnT&lt;Tp&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>RawAddressofReturnType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" line="67" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" bodystart="69" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_meta_2_utils_8hpp_1a79a2a8a0d137223d3609ef437b693a5a" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename RawAddressofReturnType&lt; T &gt;::type</type>
        <definition>using Raven::Meta::Detail::RawAddressofReturnTypeT = typedef typename RawAddressofReturnType&lt;T&gt;::type</definition>
        <argsstring></argsstring>
        <name>RawAddressofReturnTypeT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" line="72" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" bodystart="72" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_wrapper_binder_8hpp_1a4aa0c504a8b6dab99ecd4ab63ccefb51" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="struct_raven_1_1_meta_1_1_wrapper_binder" kindref="compound">WrapperBinder</ref>&lt; typename std::remove_cv_t&lt; typename std::remove_reference_t&lt; T &gt; &gt;&gt;::WrappedT</type>
        <definition>using Raven::Meta::Detail::WrapperBinderT = typedef typename WrapperBinder&lt;typename std::remove_cv_t&lt;typename std::remove_reference_t&lt;T&gt; &gt;&gt;::WrappedT</definition>
        <argsstring></argsstring>
        <name>WrapperBinderT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/WrapperBinder.hpp" line="82" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/WrapperBinder.hpp" bodystart="82" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_wrapper_binder_8hpp_1a7d1a6488af2f8af6c98d0cc26f91dbec" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::integral_constant&lt; bool, !std::is_same&lt; <ref refid="struct_raven_1_1_meta_1_1_detail_1_1_invalid_wrapped_type" kindref="compound">InvalidWrappedType</ref>, WrapperBinderT&lt; T &gt; &gt;::value &gt;</type>
        <definition>using Raven::Meta::Detail::IsWrapper = typedef std::integral_constant&lt;bool, !std::is_same&lt;InvalidWrappedType, WrapperBinderT&lt;T&gt; &gt;::value&gt;</definition>
        <argsstring></argsstring>
        <name>IsWrapper</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/WrapperBinder.hpp" line="85" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/WrapperBinder.hpp" bodystart="85" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_wrapper_binder_8hpp_1a32621ea8272a2bd7c3b002359f8c84af" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::conditional_t&lt; IsWrapper&lt; T &gt;::value, RawAddressofReturnTypeT&lt; WrapperBinderT&lt; T &gt; &gt;, RawAddressofReturnTypeT&lt; T &gt; &gt;</type>
        <definition>using Raven::Meta::Detail::WrapperAddressReturnType = typedef std::conditional_t&lt;IsWrapper&lt;T&gt;::value, RawAddressofReturnTypeT&lt;WrapperBinderT&lt;T&gt; &gt;, RawAddressofReturnTypeT&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>WrapperAddressReturnType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/WrapperBinder.hpp" line="88" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/WrapperBinder.hpp" bodystart="90" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="_type_desc_8hpp_1ad00f26cf57e41a3ec528e1b1f4a62da8" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>TypeTraitsInfos</type>
            <declname>Trait</declname>
            <defname>Trait</defname>
          </param>
          <param>
            <type>typename StdTrait</type>
          </param>
        </templateparamlist>
        <type>constexpr TypeTraitVal</type>
        <definition>constexpr TypeTraitVal Raven::Meta::Detail::TestTrait</definition>
        <argsstring>()</argsstring>
        <name>TestTrait</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeDesc.hpp" line="82" column="31" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeDesc.hpp" bodystart="82" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="_type_desc_8hpp_1a17a8238dffcfda3c786c937ce20f30a9" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>TypeTraitsInfos</type>
            <declname>Trait</declname>
            <defname>Trait</defname>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool Raven::Meta::Detail::TestTrait</definition>
        <argsstring>(TypeData *pType)</argsstring>
        <name>TestTrait</name>
        <param>
          <type><ref refid="struct_raven_1_1_meta_1_1_type_data" kindref="compound">TypeData</ref> *</type>
          <declname>pType</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeDesc.hpp" line="88" column="23" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeDesc.hpp" bodystart="88" bodyend="91"/>
      </memberdef>
      <memberdef kind="function" id="_type_desc_8hpp_1aa3a20390afc389bef5cec1b0af9b9769" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename WrapperT</type>
          </param>
          <param>
            <type>typename WrappedTypeT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Raven::Meta::Detail::CreateWrapper</definition>
        <argsstring>(const Argument &amp;arg, Variant &amp;out)</argsstring>
        <name>CreateWrapper</name>
        <param>
          <type>const <ref refid="class_raven_1_1_meta_1_1_argument" kindref="compound">Argument</ref> &amp;</type>
          <declname>arg</declname>
        </param>
        <param>
          <type><ref refid="class_raven_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeDesc.hpp" line="118" column="13" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeDesc.hpp" bodystart="118" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="_type_desc_8hpp_1a5f936ab0ccfb0285d3b36211d4047897" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename WrapperT</type>
          </param>
          <param>
            <type>typename T</type>
            <defval>WrapperBinderT&lt;WrapperT&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; IsWrapper&lt; WrapperT &gt;::value &amp;&amp;std::is_copy_constructible_v&lt; WrapperT &gt; &amp;&amp;std::is_default_constructible_v&lt; WrapperT &gt;, Interface::CreateWrapperFn &gt;</type>
        <definition>std::enable_if_t&lt; IsWrapper&lt;WrapperT&gt;::value &amp;&amp; std::is_copy_constructible_v&lt;WrapperT&gt; &amp;&amp; std::is_default_constructible_v&lt;WrapperT&gt;, Interface::CreateWrapperFn&gt; Raven::Meta::Detail::GetCreateWrapperFn</definition>
        <argsstring>()</argsstring>
        <name>GetCreateWrapperFn</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeDesc.hpp" line="132" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeDesc.hpp" bodystart="132" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="_type_desc_8hpp_1afc469c4ebee5034f720e8b1d720760b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename WrapperT</type>
          </param>
          <param>
            <type>typename T</type>
            <defval>WrapperBinderT&lt;WrapperT&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt;!IsWrapper&lt; WrapperT &gt;::value||!std::is_copy_constructible_v&lt; WrapperT &gt;||!std::is_default_constructible_v&lt; WrapperT &gt;, Interface::CreateWrapperFn &gt;</type>
        <definition>std::enable_if_t&lt;!IsWrapper&lt;WrapperT&gt;::value || !std::is_copy_constructible_v&lt;WrapperT&gt; || !std::is_default_constructible_v&lt;WrapperT&gt;, Interface::CreateWrapperFn&gt; Raven::Meta::Detail::GetCreateWrapperFn</definition>
        <argsstring>()</argsstring>
        <name>GetCreateWrapperFn</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeDesc.hpp" line="141" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeDesc.hpp" bodystart="141" bodyend="144"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1af83bc091b8a9d56673e5f6dca1758851" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Raven::Meta::Detail::IsWrappedEnum</definition>
        <argsstring>(const Argument &amp;from)</argsstring>
        <name>IsWrappedEnum</name>
        <param>
          <type>const <ref refid="class_raven_1_1_meta_1_1_argument" kindref="compound">Argument</ref> &amp;</type>
          <declname>from</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="11" column="13" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="11" bodyend="19"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1ad5e80676006fdc1338403250d408b00a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; std::is_same_v&lt; From, To &gt;, bool &gt;::type</type>
        <definition>std::enable_if&lt;std::is_same_v&lt;From, To&gt;, bool&gt;::type Raven::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="82" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="82" bodyend="86"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1ad2958d293b9770568709730e0cbc3471" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; AreIntegrals&lt; From, To &gt;::value &amp;&amp;!std::is_signed_v&lt; From &gt; &amp;&amp;std::is_signed_v&lt; To &gt;, bool &gt;</type>
        <definition>std::enable_if_t&lt;AreIntegrals&lt;From, To&gt;::value &amp;&amp; !std::is_signed_v&lt;From&gt; &amp;&amp; std::is_signed_v&lt;To&gt;, bool&gt; Raven::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="90" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="90" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1ad46b4eeba2cd177616692f11f51a3119" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; AreIntegrals&lt; From, To &gt;::value &amp;&amp;std::is_signed_v&lt; From &gt; &amp;&amp;!std::is_signed_v&lt; To &gt;, bool &gt;</type>
        <definition>std::enable_if_t&lt;AreIntegrals&lt;From, To&gt;::value &amp;&amp; std::is_signed_v&lt;From&gt; &amp;&amp; !std::is_signed_v&lt;To&gt;, bool&gt; Raven::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="101" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="101" bodyend="111"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a1973e328deba5cffdf44232bb9ebbce2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; AreIntegrals&lt; From, To &gt;::value &amp;&amp;std::is_signed_v&lt; From &gt; &amp;&amp;std::is_signed_v&lt; To &gt;, bool &gt;</type>
        <definition>std::enable_if_t&lt;AreIntegrals&lt;From, To&gt;::value &amp;&amp; std::is_signed_v&lt;From&gt; &amp;&amp; std::is_signed_v&lt;To&gt;, bool&gt; Raven::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="115" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="115" bodyend="124"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1ac732b8e63a5a9efc47908766afa0d560" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; AreIntegrals&lt; From, To &gt;::value &amp;&amp;!std::is_signed_v&lt; From &gt; &amp;&amp;!std::is_signed_v&lt; To &gt;, bool &gt;</type>
        <definition>std::enable_if_t&lt;AreIntegrals&lt;From, To&gt;::value &amp;&amp; !std::is_signed_v&lt;From&gt; &amp;&amp; !std::is_signed_v&lt;To&gt;, bool&gt; Raven::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="128" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="128" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a444d2ac0d7edece8100a3b3f4a987de5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_floating_point_v&lt; From &gt; &amp;&amp;std::is_integral_v&lt; To &gt; &amp;&amp;!std::is_signed_v&lt; To &gt;, bool &gt;</type>
        <definition>std::enable_if_t&lt;std::is_floating_point_v&lt;From&gt; &amp;&amp; std::is_integral_v&lt;To&gt; &amp;&amp; !std::is_signed_v&lt;To&gt;, bool&gt; Raven::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="141" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="141" bodyend="148"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a72ca59a603e661c1411fc314fc8bf27e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_floating_point_v&lt; From &gt; &amp;&amp;std::is_integral_v&lt; To &gt; &amp;&amp;std::is_signed_v&lt; To &gt;, bool &gt;</type>
        <definition>std::enable_if_t&lt;std::is_floating_point_v&lt;From&gt; &amp;&amp; std::is_integral_v&lt;To&gt; &amp;&amp; std::is_signed_v&lt;To&gt;, bool&gt; Raven::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="152" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="152" bodyend="161"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1ab4317faa2d633990fa8615c572dca6f8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Raven::Meta::Detail::ToEnumeration</definition>
        <argsstring>(std::string_view name, Argument &amp;to)</argsstring>
        <name>ToEnumeration</name>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="class_raven_1_1_meta_1_1_argument" kindref="compound">Argument</ref> &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="167" column="13" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="167" bodyend="179"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1aa60da683e2e4b1231c2078a1ccc878d7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Raven::Meta::Detail::ToEnumeration</definition>
        <argsstring>(const Variant &amp;from, Argument &amp;to)</argsstring>
        <name>ToEnumeration</name>
        <param>
          <type>const <ref refid="class_raven_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type><ref refid="class_raven_1_1_meta_1_1_argument" kindref="compound">Argument</ref> &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="181" column="13" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="181" bodyend="207"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a303f26cae22d29b8ccbf7a6f9ebbf3ce" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Raven::Meta::Detail::StringToBool</definition>
        <argsstring>(std::string src, bool *bOk)</argsstring>
        <name>StringToBool</name>
        <param>
          <type>std::string</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="1248" column="13" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="1248" bodyend="1267"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1ace0cc4fc3cd78bc36df2ae50d1eb25aa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int Raven::Meta::Detail::StringToI32</definition>
        <argsstring>(const std::string &amp;src, bool *bOk)</argsstring>
        <name>StringToI32</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="1269" column="12" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="1269" bodyend="1288"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1aacd6c9ab2722defebac2b31a100b320c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::uint32_t</type>
        <definition>std::uint32_t Raven::Meta::Detail::StringToU32</definition>
        <argsstring>(const std::string &amp;src, bool *bOk)</argsstring>
        <name>StringToU32</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="1290" column="22" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="1290" bodyend="1310"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a0911ad8694406385a60bd4924bba225f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::int64_t</type>
        <definition>std::int64_t Raven::Meta::Detail::StringToI64</definition>
        <argsstring>(const std::string &amp;src, bool *bOk)</argsstring>
        <name>StringToI64</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="1312" column="21" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="1312" bodyend="1330"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a3a7fc261740ff7e6f298c531e5abb849" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::uint64_t</type>
        <definition>std::uint64_t Raven::Meta::Detail::StringToU64</definition>
        <argsstring>(const std::string &amp;src, bool *bOk)</argsstring>
        <name>StringToU64</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="1332" column="22" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="1332" bodyend="1356"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1ac2fd71fb766c77f07261e01f06032697" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>float Raven::Meta::Detail::StringToF32</definition>
        <argsstring>(const std::string &amp;src, bool *bOk)</argsstring>
        <name>StringToF32</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="1358" column="14" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="1358" bodyend="1377"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1acfeb546140f9ffd291955ae7b933a31c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double Raven::Meta::Detail::StringToF64</definition>
        <argsstring>(const std::string &amp;src, bool *bOk)</argsstring>
        <name>StringToF64</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" line="1379" column="15" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/TypeCasting.hpp" bodystart="1379" bodyend="1398"/>
      </memberdef>
      <memberdef kind="function" id="_variant_8hpp_1a94a05477480f5b73e83e4d1c9eb3bb44" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_raven_1_1_meta_1_1_type" kindref="compound">Type</ref></type>
        <definition>Type Raven::Meta::Detail::GetVariantType</definition>
        <argsstring>(const Variant &amp;var)</argsstring>
        <name>GetVariantType</name>
        <param>
          <type>const <ref refid="class_raven_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &amp;</type>
          <declname>var</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Variant.hpp" line="266" column="13" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Variant.hpp" bodystart="266" bodyend="268" declfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" declline="29" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="_variant_8hpp_1a22bca2a81541bd5cdb32a99b7739f442" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Raven::Meta::Detail::VariantEqCmp</definition>
        <argsstring>(const Type &amp;rhsType, const Variant &amp;rhs, const Type &amp;lhsType, const Variant &amp;lhs, bool *bOk)</argsstring>
        <name>VariantEqCmp</name>
        <param>
          <type>const <ref refid="class_raven_1_1_meta_1_1_type" kindref="compound">Type</ref> &amp;</type>
          <declname>rhsType</declname>
        </param>
        <param>
          <type>const <ref refid="class_raven_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <param>
          <type>const <ref refid="class_raven_1_1_meta_1_1_type" kindref="compound">Type</ref> &amp;</type>
          <declname>lhsType</declname>
        </param>
        <param>
          <type>const <ref refid="class_raven_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Variant.hpp" line="270" column="13" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Variant.hpp" bodystart="270" bodyend="286" declfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" declline="30" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="_variant_8hpp_1a0c7b193ee4ae1f00970752f86a085a80" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename InvokerT</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Raven::Meta::Detail::EqCmp</definition>
        <argsstring>(const Type &amp;, const VariantData &amp;rhs, const Type &amp;, const Variant &amp;lhs, bool *bOk)</argsstring>
        <name>EqCmp</name>
        <param>
          <type>const <ref refid="class_raven_1_1_meta_1_1_type" kindref="compound">Type</ref> &amp;</type>
          <defname>rhsType</defname>
        </param>
        <param>
          <type>const VariantData &amp;</type>
          <declname>rhs</declname>
        </param>
        <param>
          <type>const <ref refid="class_raven_1_1_meta_1_1_type" kindref="compound">Type</ref> &amp;</type>
          <defname>lhsType</defname>
        </param>
        <param>
          <type>const <ref refid="class_raven_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Variant.hpp" line="289" column="6" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Variant.hpp" bodystart="289" bodyend="306" declfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" declline="32" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1a2daba9c3e177adf81fa6242044b59abc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Raven::Meta::Detail::IsFloatingPoint</definition>
        <argsstring>(const Type &amp;t)</argsstring>
        <name>IsFloatingPoint</name>
        <param>
          <type>const <ref refid="class_raven_1_1_meta_1_1_type" kindref="compound">Type</ref> &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" line="25" column="13" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" bodystart="25" bodyend="27"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1abaf67defbf333518dcc21b9b72a82053" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; Detail::IsSequentialContainer&lt; T &gt;::value, <ref refid="class_raven_1_1_meta_1_1_variant_sequential_view" kindref="compound">VariantSequentialView</ref> &gt;</type>
        <definition>std::enable_if_t&lt; Detail::IsSequentialContainer&lt; T &gt;::value, VariantSequentialView &gt; Raven::Meta::Detail::CreateVariantSequentialView</definition>
        <argsstring>(T &amp;&amp;val)</argsstring>
        <name>CreateVariantSequentialView</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/SequentialContainerBinder.hpp" line="340" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/SequentialContainerBinder.hpp" bodystart="340" bodyend="343" declfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" declline="35" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1a8c840f81765c2113b5feaa0b549328e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt;!Detail::IsSequentialContainer&lt; T &gt;::value, <ref refid="class_raven_1_1_meta_1_1_variant_sequential_view" kindref="compound">VariantSequentialView</ref> &gt;</type>
        <definition>std::enable_if_t&lt;!Detail::IsSequentialContainer&lt; T &gt;::value, VariantSequentialView &gt; Raven::Meta::Detail::CreateVariantSequentialView</definition>
        <argsstring>(T &amp;&amp;val)</argsstring>
        <name>CreateVariantSequentialView</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/SequentialContainerBinder.hpp" line="347" column="1" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/SequentialContainerBinder.hpp" bodystart="347" bodyend="350" declfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" declline="37" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1ab58a982211b8bef349b3993c7833c5df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; Detail::IsAssociativeContainer&lt; T &gt;::value, <ref refid="class_raven_1_1_meta_1_1_variant_associative_view" kindref="compound">VariantAssociativeView</ref> &gt;</type>
        <definition>std::enable_if_t&lt; Detail::IsAssociativeContainer&lt; T &gt;::value, VariantAssociativeView &gt; Raven::Meta::Detail::CreateVariantAssociativeView</definition>
        <argsstring>(T &amp;&amp;val)</argsstring>
        <name>CreateVariantAssociativeView</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/AssociativeContainerBinder.hpp" line="424" column="19" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/AssociativeContainerBinder.hpp" bodystart="424" bodyend="427" declfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" declline="40" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1ad0ec2d9e0e460997d548a9c378234db2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt;!Detail::IsAssociativeContainer&lt; T &gt;::value, <ref refid="class_raven_1_1_meta_1_1_variant_associative_view" kindref="compound">VariantAssociativeView</ref> &gt;</type>
        <definition>std::enable_if_t&lt;!Detail::IsAssociativeContainer&lt; T &gt;::value, VariantAssociativeView &gt; Raven::Meta::Detail::CreateVariantAssociativeView</definition>
        <argsstring>(T &amp;&amp;val)</argsstring>
        <name>CreateVariantAssociativeView</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/AssociativeContainerBinder.hpp" line="430" column="19" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/AssociativeContainerBinder.hpp" bodystart="430" bodyend="433" declfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" declline="42" declcolumn="19"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1ad2a3ebe44bc097240a0f18dda8c5ef7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Tp</type>
            <defval>std::remove_cv_t&lt;T&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_copy_constructible_v&lt; Tp &gt; &amp;&amp;IsWrapper&lt; T &gt;::value, <ref refid="class_raven_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &gt;</type>
        <definition>std::enable_if_t&lt;std::is_copy_constructible_v&lt;Tp&gt; &amp;&amp; IsWrapper&lt;T&gt;::value, Variant&gt; Raven::Meta::Detail::GetWrappedValue</definition>
        <argsstring>(T &amp;value)</argsstring>
        <name>GetWrappedValue</name>
        <param>
          <type>T &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" line="45" column="19" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" bodystart="45" bodyend="48"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1a2a183fc180a871bcc7912a9b173fdfef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Tp</type>
            <defval>std::remove_cv_t&lt;T&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt;!std::is_copy_constructible_v&lt; Tp &gt;||!IsWrapper&lt; T &gt;::value, <ref refid="class_raven_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &gt;</type>
        <definition>std::enable_if_t&lt;!std::is_copy_constructible_v&lt;Tp&gt; || !IsWrapper&lt;T&gt;::value, Variant&gt; Raven::Meta::Detail::GetWrappedValue</definition>
        <argsstring>(T &amp;)</argsstring>
        <name>GetWrappedValue</name>
        <param>
          <type>T &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" line="51" column="19" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/VariantPolicy.hpp" bodystart="51" bodyend="53"/>
      </memberdef>
      <memberdef kind="function" id="_meta_2_utils_8hpp_1ad077a148f215c82c32e5068c1e85e0f9" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>RawAddressofReturnTypeT&lt; T &gt;</type>
        <definition>static RawAddressofReturnTypeT&lt;T&gt; Raven::Meta::Detail::RawAddressOf</definition>
        <argsstring>(T &amp;data)</argsstring>
        <name>RawAddressOf</name>
        <param>
          <type>T &amp;</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" line="86" column="39" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/Utils.hpp" bodystart="86" bodyend="89"/>
      </memberdef>
      <memberdef kind="function" id="_wrapper_binder_8hpp_1a10ce16fe0a5c0f7fdc657661e8e9a4f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; IsWrapper&lt; T &gt;::value, RawAddressofReturnTypeT&lt; WrapperBinderT&lt; T &gt; &gt; &gt;</type>
        <definition>std::enable_if_t&lt;IsWrapper&lt;T&gt;::value, RawAddressofReturnTypeT&lt;WrapperBinderT&lt;T&gt; &gt; &gt; Raven::Meta::Detail::WrappedRawAddressOf</definition>
        <argsstring>(T &amp;obj)</argsstring>
        <name>WrappedRawAddressOf</name>
        <param>
          <type>T &amp;</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/WrapperBinder.hpp" line="93" column="28" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/WrapperBinder.hpp" bodystart="93" bodyend="98"/>
      </memberdef>
      <memberdef kind="function" id="_wrapper_binder_8hpp_1a700cea507a2677e1a611b0eb4b16bb74" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt;!IsWrapper&lt; T &gt;::value, RawAddressofReturnTypeT&lt; T &gt; &gt;</type>
        <definition>std::enable_if_t&lt;!IsWrapper&lt;T&gt;::value, RawAddressofReturnTypeT&lt;T&gt; &gt; Raven::Meta::Detail::WrappedRawAddressOf</definition>
        <argsstring>(T &amp;obj)</argsstring>
        <name>WrappedRawAddressOf</name>
        <param>
          <type>T &amp;</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/WrapperBinder.hpp" line="101" column="28" bodyfile="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/WrapperBinder.hpp" bodystart="101" bodyend="104"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/runner/work/RavenEngine/RavenEngine/Raven/Code/RavenCommon/Meta/PropertyTraits.hpp" line="11" column="1"/>
  </compounddef>
</doxygen>
