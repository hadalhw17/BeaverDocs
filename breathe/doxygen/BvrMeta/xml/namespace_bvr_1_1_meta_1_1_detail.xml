<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespace_bvr_1_1_meta_1_1_detail" kind="namespace" language="C++">
    <compoundname>Bvr::Meta::Detail</compoundname>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from" prot="public">Bvr::Meta::Detail::CastFrom</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_enum" prot="public">Bvr::Meta::Detail::CastFromEnum</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_default_caster" prot="public">Bvr::Meta::Detail::DefaultCaster</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_empty_caster" prot="public">Bvr::Meta::Detail::EmptyCaster</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_prop__" prot="public">Bvr::Meta::Detail::Prop_</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_enum__" prot="public">Bvr::Meta::Detail::Enum_</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_meth__" prot="public">Bvr::Meta::Detail::Meth_</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_associative_container_binder" prot="public">Bvr::Meta::Detail::AssociativeContainerBinder</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_associative_container_value" prot="public">Bvr::Meta::Detail::AssociativeContainerValue</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_associative_container_binder_base" prot="public">Bvr::Meta::Detail::AssociativeContainerBinderBase</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_associative_container_binder_base_map" prot="public">Bvr::Meta::Detail::AssociativeContainerBinderBaseMap</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_associative_container_binder_base_set" prot="public">Bvr::Meta::Detail::AssociativeContainerBinderBaseSet</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_associative_container_binder_3_01std_1_1unordered__set_3_01_t_01_4_01_4" prot="public">Bvr::Meta::Detail::AssociativeContainerBinder&lt; std::unordered_set&lt; T &gt; &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_associative_container_binder_3_01std_1_1unordered__map_3_01_t_00_01_u_01_4_01_4" prot="public">Bvr::Meta::Detail::AssociativeContainerBinder&lt; std::unordered_map&lt; T, U &gt; &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_associative_container_binder_3_01std_1_1set_3_01_t_01_4_01_4" prot="public">Bvr::Meta::Detail::AssociativeContainerBinder&lt; std::set&lt; T &gt; &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_associative_container_binder_3_01std_1_1map_3_01_t_00_01_u_01_4_01_4" prot="public">Bvr::Meta::Detail::AssociativeContainerBinder&lt; std::map&lt; T, U &gt; &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_associative_container_binder_wrapper" prot="public">Bvr::Meta::Detail::AssociativeContainerBinderWrapper</innerclass>
    <innerclass refid="class_bvr_1_1_meta_1_1_detail_1_1_enum_data" prot="public">Bvr::Meta::Detail::EnumData</innerclass>
    <innerclass refid="class_bvr_1_1_meta_1_1_detail_1_1_enum_wrapper_base" prot="public">Bvr::Meta::Detail::EnumWrapperBase</innerclass>
    <innerclass refid="class_bvr_1_1_meta_1_1_detail_1_1_enum_wrapper" prot="public">Bvr::Meta::Detail::EnumWrapper</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_invalid_wrapped_type" prot="public">Bvr::Meta::Detail::InvalidWrappedType</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_sequential_container_binder" prot="public">Bvr::Meta::Detail::SequentialContainerBinder</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_sequential_container_binder_dynamic" prot="public">Bvr::Meta::Detail::SequentialContainerBinderDynamic</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_sequential_container_binder_direct_access" prot="public">Bvr::Meta::Detail::SequentialContainerBinderDirectAccess</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_sequential_container_binder_3_01std_1_1vector_3_01_t_01_4_01_4" prot="public">Bvr::Meta::Detail::SequentialContainerBinder&lt; std::vector&lt; T &gt; &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_sequential_container_binder_wrapper" prot="public">Bvr::Meta::Detail::SequentialContainerBinderWrapper</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_template_argument_extractor" prot="public">Bvr::Meta::Detail::TemplateArgumentExtractor</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_template_argument_extractor_3_01_t_3_01_args_8_8_8_01_4_01_4" prot="public">Bvr::Meta::Detail::TemplateArgumentExtractor&lt; T&lt; Args... &gt; &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_wrapper_type_meta" prot="public">Bvr::Meta::Detail::WrapperTypeMeta</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_create_empty_variant_policy" prot="public">Bvr::Meta::Detail::CreateEmptyVariantPolicy</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_3_01bool_01_4" prot="public">Bvr::Meta::Detail::CastFrom&lt; bool &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_3_01char_01_4" prot="public">Bvr::Meta::Detail::CastFrom&lt; char &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1int8__t_01_4" prot="public">Bvr::Meta::Detail::CastFrom&lt; std::int8_t &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1uint8__t_01_4" prot="public">Bvr::Meta::Detail::CastFrom&lt; std::uint8_t &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1int16__t_01_4" prot="public">Bvr::Meta::Detail::CastFrom&lt; std::int16_t &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1uint16__t_01_4" prot="public">Bvr::Meta::Detail::CastFrom&lt; std::uint16_t &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1int32__t_01_4" prot="public">Bvr::Meta::Detail::CastFrom&lt; std::int32_t &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1uint32__t_01_4" prot="public">Bvr::Meta::Detail::CastFrom&lt; std::uint32_t &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1int64__t_01_4" prot="public">Bvr::Meta::Detail::CastFrom&lt; std::int64_t &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1uint64__t_01_4" prot="public">Bvr::Meta::Detail::CastFrom&lt; std::uint64_t &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_3_01float_01_4" prot="public">Bvr::Meta::Detail::CastFrom&lt; float &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_3_01double_01_4" prot="public">Bvr::Meta::Detail::CastFrom&lt; double &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_3_01std_1_1string_01_4" prot="public">Bvr::Meta::Detail::CastFrom&lt; std::string &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_t_method_traits" prot="public">Bvr::Meta::Detail::TMethodTraits</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_remove_all_pointers" prot="public">Bvr::Meta::Detail::RemoveAllPointers</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_remove_all_pointers_3_01_t_00_01std_1_1enable__if__t_3_01std_171676dd77f4cce0eabd5a40f93a089d" prot="public">Bvr::Meta::Detail::RemoveAllPointers&lt; T, std::enable_if_t&lt; std::is_pointer_v&lt; T &gt; &gt; &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_remove_all_pointers_except_one" prot="public">Bvr::Meta::Detail::RemoveAllPointersExceptOne</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_remove_all_pointers_except_one_3_01_t_00_01std_1_1enable__if_d1333ed47a5ddd7f3828f7ffef4a6ddc" prot="public">Bvr::Meta::Detail::RemoveAllPointersExceptOne&lt; T, std::enable_if_t&lt; std::is_pointer_v&lt; T &gt; &gt; &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_raw_type" prot="public">Bvr::Meta::Detail::RawType</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_raw_type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__poin9436a7cf15a31eb8f9403a369798d069" prot="public">Bvr::Meta::Detail::RawType&lt; T, std::enable_if_t&lt; std::is_pointer_v&lt; T &gt; &amp;&amp;!IsFunctionPtr&lt; T &gt;::value &gt; &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_raw_type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__refeaa579c6759de9c3c8c68ffac5191b786" prot="public">Bvr::Meta::Detail::RawType&lt; T, std::enable_if_t&lt; std::is_reference_v&lt; T &gt; &amp;&amp;!IsFunctionPtr&lt; T &gt;::value &gt; &gt;</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_raw_address_of_impl" prot="public">Bvr::Meta::Detail::RawAddressOfImpl</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_object_memory_storage" prot="public">Bvr::Meta::Detail::ObjectMemoryStorage</innerclass>
    <innerclass refid="struct_bvr_1_1_meta_1_1_detail_1_1_has_is_valid_alias" prot="public">Bvr::Meta::Detail::HasIsValidAlias</innerclass>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="_variant_policy_8hpp_1a5617422f9121b4823dfbcd10a8aa927c" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="struct_bvr_1_1_meta_1_1_detail_1_1_default_caster" kindref="compound">DefaultCaster</ref>&lt; T, <ref refid="struct_bvr_1_1_meta_1_1_detail_1_1_cast_from_enum" kindref="compound">CastFromEnum</ref>&lt; T &gt; &gt;</type>
        <definition>using Bvr::Meta::Detail::EnumCaster = typedef DefaultCaster&lt;T, CastFromEnum&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>EnumCaster</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" line="18" column="17" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" bodystart="18" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_wrapper_binder_8hpp_1a051e93a792e7b992ad949eac1f3861ed" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="struct_bvr_1_1_meta_1_1_wrapper_binder" kindref="compound">WrapperBinder</ref>&lt; typename std::remove_cv_t&lt; typename std::remove_reference_t&lt; T &gt; &gt;&gt;::WrappedT</type>
        <definition>using Bvr::Meta::Detail::WrapperBinderT = typedef typename WrapperBinder&lt;typename std::remove_cv_t&lt; typename std::remove_reference_t&lt;T&gt; &gt;&gt;::WrappedT</definition>
        <argsstring></argsstring>
        <name>WrapperBinderT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/WrapperBinder.hpp" line="53" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/WrapperBinder.hpp" bodystart="54" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_wrapper_binder_8hpp_1a170c09bc725f9d2e8351c1c0cda5da35" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::integral_constant&lt; bool, !std::is_same&lt; <ref refid="struct_bvr_1_1_meta_1_1_detail_1_1_invalid_wrapped_type" kindref="compound">InvalidWrappedType</ref>, WrapperBinderT&lt; T &gt; &gt;::value &gt;</type>
        <definition>using Bvr::Meta::Detail::IsWrapper = typedef std::integral_constant&lt; bool, !std::is_same&lt;InvalidWrappedType, WrapperBinderT&lt;T&gt; &gt;::value&gt;</definition>
        <argsstring></argsstring>
        <name>IsWrapper</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/WrapperBinder.hpp" line="57" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/WrapperBinder.hpp" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_wrapper_binder_8hpp_1a9dcac2db4272b476b86002a09d1171ec" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::conditional_t&lt; IsWrapper&lt; T &gt;::value, RawAddressofReturnTypeT&lt; WrapperBinderT&lt; T &gt; &gt;, RawAddressofReturnTypeT&lt; T &gt; &gt;</type>
        <definition>using Bvr::Meta::Detail::WrapperAddressReturnType = typedef std::conditional_t&lt;IsWrapper&lt;T&gt;::value, RawAddressofReturnTypeT&lt;WrapperBinderT&lt;T&gt; &gt;, RawAddressofReturnTypeT&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>WrapperAddressReturnType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/WrapperBinder.hpp" line="61" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/WrapperBinder.hpp" bodystart="64" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_type_desc_8hpp_1a680e583ee4dc9ce964e3f9a68dd3f1c4" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename std::conditional_t&lt; std::is_abstract_v&lt; T &gt;||!std::is_default_constructible_v&lt; T &gt;||!std::is_copy_constructible_v&lt; T &gt;, <ref refid="struct_bvr_1_1_meta_1_1_detail_1_1_create_empty_variant_policy" kindref="compound">CreateEmptyVariantPolicy</ref>, CreateVariantPolicy&lt; T &gt; &gt;</type>
        <definition>using Bvr::Meta::Detail::CreateVariantPolicyT = typedef typename std::conditional_t&lt; std::is_abstract_v&lt;T&gt; || !std::is_default_constructible_v&lt;T&gt; || !std::is_copy_constructible_v&lt;T&gt;, CreateEmptyVariantPolicy, CreateVariantPolicy&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>CreateVariantPolicyT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" line="168" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" bodystart="171" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_type_casting_8hpp_1a07198b9e93e9689cec745af5c805355c" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename A</type>
          </param>
          <param>
            <type>typename B</type>
          </param>
        </templateparamlist>
        <type>std::integral_constant&lt; bool, !std::is_same_v&lt; A, B &gt; &amp;&amp;std::is_integral_v&lt; A &gt; &amp;&amp;std::is_integral_v&lt; B &gt; &gt;</type>
        <definition>using Bvr::Meta::Detail::AreIntegrals = typedef std::integral_constant&lt;bool, !std::is_same_v&lt;A, B&gt; &amp;&amp; std::is_integral_v&lt;A&gt; &amp;&amp; std::is_integral_v&lt;B&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>AreIntegrals</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="63" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="66" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_utils_8hpp_1a8c74fc7f1271478d0ba48e4d6a423874" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="struct_bvr_1_1_meta_1_1_detail_1_1_remove_all_pointers" kindref="compound">RemoveAllPointers</ref>&lt; T &gt;::<ref refid="class_bvr_1_1_meta_1_1_type" kindref="compound">Type</ref></type>
        <definition>using Bvr::Meta::Detail::RemoveAllPointersT = typedef typename RemoveAllPointers&lt;T&gt;::Type</definition>
        <argsstring></argsstring>
        <name>RemoveAllPointersT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" line="15" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" bodystart="15" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_utils_8hpp_1a51a2f0daac8607220a9cbf9dc690c7f6" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="struct_bvr_1_1_meta_1_1_detail_1_1_remove_all_pointers_except_one" kindref="compound">RemoveAllPointersExceptOne</ref>&lt; T &gt;::<ref refid="class_bvr_1_1_meta_1_1_type" kindref="compound">Type</ref></type>
        <definition>using Bvr::Meta::Detail::RemoveAllPointersExceptOneT = typedef typename RemoveAllPointersExceptOne&lt;T&gt;::Type</definition>
        <argsstring></argsstring>
        <name>RemoveAllPointersExceptOneT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" line="32" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" bodystart="33" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_utils_8hpp_1ad6183e7d32ba47078ad3e1dedda1c2d9" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::integral_constant&lt; bool, std::is_pointer_v&lt; T &gt; &amp;&amp;std::is_function_v&lt; std::remove_pointer_t&lt; T &gt; &gt;&gt;</type>
        <definition>using Bvr::Meta::Detail::IsFunctionPtr = typedef std::integral_constant&lt; bool, std::is_pointer_v&lt;T&gt; &amp;&amp; std::is_function_v&lt;std::remove_pointer_t&lt;T&gt; &gt;&gt;</definition>
        <argsstring></argsstring>
        <name>IsFunctionPtr</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" line="36" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" bodystart="38" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_utils_8hpp_1a4e12702a6e5432551840fa9839f3488f" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename <ref refid="struct_bvr_1_1_meta_1_1_detail_1_1_raw_type" kindref="compound">RawType</ref>&lt; T &gt;::<ref refid="class_bvr_1_1_meta_1_1_type" kindref="compound">Type</ref></type>
        <definition>using Bvr::Meta::Detail::RawTypeT = typedef typename RawType&lt;T&gt;::Type</definition>
        <argsstring></argsstring>
        <name>RawTypeT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" line="56" column="17" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" bodystart="56" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_utils_8hpp_1acf166572eb00f6a7ffa4a43f04ef8270" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>typename std::add_pointer_t&lt; RemoveAllPointersT&lt; T &gt; &gt;</type>
        <definition>using Bvr::Meta::Detail::NormalReturnT = typedef typename std::add_pointer_t&lt;RemoveAllPointersT&lt;T&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>NormalReturnT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" line="59" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" bodystart="59" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_utils_8hpp_1a031c3a7cbee1ea575f6da6e8753eff86" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Tp</type>
            <defval>std::remove_reference_t&lt;T&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::conditional_t&lt; IsFunctionPtr&lt; RemoveAllPointersExceptOneT&lt; Tp &gt; &gt;::value, std::add_pointer_t&lt; RemoveAllPointersExceptOneT&lt; Tp &gt; &gt;, NormalReturnT&lt; Tp &gt; &gt;</type>
        <definition>using Bvr::Meta::Detail::RawAddressofReturnType = typedef std::conditional_t&lt; IsFunctionPtr&lt;RemoveAllPointersExceptOneT&lt;Tp&gt; &gt;::value, std::add_pointer_t&lt;RemoveAllPointersExceptOneT&lt;Tp&gt; &gt;, NormalReturnT&lt;Tp&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>RawAddressofReturnType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" line="62" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" bodystart="64" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_utils_8hpp_1a51dc73ad78bd883aa63d7b29e8da2639" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>RawAddressofReturnType&lt; T &gt;</type>
        <definition>using Bvr::Meta::Detail::RawAddressofReturnTypeT = typedef RawAddressofReturnType&lt;T&gt;</definition>
        <argsstring></argsstring>
        <name>RawAddressofReturnTypeT</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" line="67" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" bodystart="67" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_property_traits_8hpp_1afa20aff544082da30b59046e43809e60" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Tp</type>
            <defval>std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::integral_constant&lt; bool, !<ref refid="struct_bvr_1_1_meta_1_1_detail_1_1_has_is_valid_alias" kindref="compound">HasIsValidAlias</ref>&lt; <ref refid="struct_bvr_1_1_meta_1_1_detail_1_1_sequential_container_binder" kindref="compound">SequentialContainerBinder</ref>&lt; Tp &gt; &gt;::Value &gt;</type>
        <definition>using Bvr::Meta::Detail::IsSequentialContainer = typedef std::integral_constant&lt; bool, !HasIsValidAlias&lt;SequentialContainerBinder&lt;Tp&gt; &gt;::Value&gt;</definition>
        <argsstring></argsstring>
        <name>IsSequentialContainer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/PropertyTraits.hpp" line="25" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/PropertyTraits.hpp" bodystart="26" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_property_traits_8hpp_1a20e5c080d1aa3531ba65c6f43e91681f" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Tp</type>
            <defval>std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::integral_constant&lt; bool, !<ref refid="struct_bvr_1_1_meta_1_1_detail_1_1_has_is_valid_alias" kindref="compound">HasIsValidAlias</ref>&lt; <ref refid="struct_bvr_1_1_meta_1_1_detail_1_1_associative_container_binder" kindref="compound">AssociativeContainerBinder</ref>&lt; Tp &gt; &gt;::Value &gt;</type>
        <definition>using Bvr::Meta::Detail::IsAssociativeContainer = typedef std::integral_constant&lt; bool, !HasIsValidAlias&lt;AssociativeContainerBinder&lt;Tp&gt; &gt;::Value&gt;</definition>
        <argsstring></argsstring>
        <name>IsAssociativeContainer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/PropertyTraits.hpp" line="30" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/PropertyTraits.hpp" bodystart="31" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="_iterator_binder_8hpp_1a488c0af2190040c17527e97724ba98d6" prot="public" static="no">
        <type>std::byte[sizeof(double)]</type>
        <definition>using Bvr::Meta::Detail::IteratorData = typedef std::byte[sizeof(double)]</definition>
        <argsstring></argsstring>
        <name>IteratorData</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/IteratorBinder.hpp" line="5" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/IteratorBinder.hpp" bodystart="5" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="_type_8hpp_1a686842ad13c591b8d2873eeb90a3f387" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="struct_bvr_1_1_meta_1_1_type_data" kindref="compound">TypeData</ref> &amp;</type>
        <definition>TypeData &amp; Bvr::Meta::Detail::MakeInvalidTypeData</definition>
        <argsstring>()</argsstring>
        <name>MakeInvalidTypeData</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" line="173" column="21" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" bodystart="173" bodyend="188" declfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Type.hpp" declline="16" declcolumn="14"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1ae3d43b6c3593faef93022f6eb0df60b6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Bvr::Meta::Detail::IsFloatingPoint</definition>
        <argsstring>(const Type &amp;t)</argsstring>
        <name>IsFloatingPoint</name>
        <param>
          <type>const <ref refid="class_bvr_1_1_meta_1_1_type" kindref="compound">Type</ref> &amp;</type>
          <declname>t</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" line="20" column="17" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" bodystart="20" bodyend="22"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1a26c9e6534b16d2713f913ea67f49c625" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_bvr_1_1_meta_1_1_type" kindref="compound">Type</ref></type>
        <definition>Type Bvr::Meta::Detail::GetVariantType</definition>
        <argsstring>(const Variant &amp;var)</argsstring>
        <name>GetVariantType</name>
        <param>
          <type>const <ref refid="class_bvr_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &amp;</type>
          <declname>var</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Variant.hpp" line="276" column="17" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Variant.hpp" bodystart="276" bodyend="278" declfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" declline="24" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1a43738667404556b1dde8bd959a2bcd50" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Bvr::Meta::Detail::VariantEqCmp</definition>
        <argsstring>(const Type &amp;rhsType, const Variant &amp;rhs, const Type &amp;lhsType, const Variant &amp;lhs, bool *bOk)</argsstring>
        <name>VariantEqCmp</name>
        <param>
          <type>const <ref refid="class_bvr_1_1_meta_1_1_type" kindref="compound">Type</ref> &amp;</type>
          <declname>rhsType</declname>
        </param>
        <param>
          <type>const <ref refid="class_bvr_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <param>
          <type>const <ref refid="class_bvr_1_1_meta_1_1_type" kindref="compound">Type</ref> &amp;</type>
          <declname>lhsType</declname>
        </param>
        <param>
          <type>const <ref refid="class_bvr_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Variant.hpp" line="280" column="17" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Variant.hpp" bodystart="280" bodyend="296" declfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" declline="25" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1a675b61d05fd216645cb39ead40d0d640" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename InvokerT</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Bvr::Meta::Detail::EqCmp</definition>
        <argsstring>(const Type &amp;rhsType, const VariantData &amp;rhs, const Type &amp;lhsType, const Variant &amp;lhs, bool *bOk)</argsstring>
        <name>EqCmp</name>
        <param>
          <type>const <ref refid="class_bvr_1_1_meta_1_1_type" kindref="compound">Type</ref> &amp;</type>
          <declname>rhsType</declname>
        </param>
        <param>
          <type>const VariantData &amp;</type>
          <declname>rhs</declname>
        </param>
        <param>
          <type>const <ref refid="class_bvr_1_1_meta_1_1_type" kindref="compound">Type</ref> &amp;</type>
          <declname>lhsType</declname>
        </param>
        <param>
          <type>const <ref refid="class_bvr_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Variant.hpp" line="299" column="10" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Variant.hpp" bodystart="299" bodyend="316" declfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" declline="29" declcolumn="17"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1aadd5bbc255f08651b51b715f560beb6d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; Detail::IsSequentialContainer&lt; T &gt;::value, <ref refid="class_bvr_1_1_meta_1_1_variant_sequential_view" kindref="compound">VariantSequentialView</ref> &gt;</type>
        <definition>std::enable_if_t&lt; Detail::IsSequentialContainer&lt; T &gt;::value, VariantSequentialView &gt; Bvr::Meta::Detail::CreateVariantSequentialView</definition>
        <argsstring>(T &amp;&amp;val)</argsstring>
        <name>CreateVariantSequentialView</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/SequentialContainerBinder.hpp" line="295" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/SequentialContainerBinder.hpp" bodystart="295" bodyend="297" declfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" declline="35" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1a1455d8c187185db77f2480975c58564a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt;!Detail::IsSequentialContainer&lt; T &gt;::value, <ref refid="class_bvr_1_1_meta_1_1_variant_sequential_view" kindref="compound">VariantSequentialView</ref> &gt;</type>
        <definition>std::enable_if_t&lt;!Detail::IsSequentialContainer&lt; T &gt;::value, VariantSequentialView &gt; Bvr::Meta::Detail::CreateVariantSequentialView</definition>
        <argsstring>(T &amp;&amp;val)</argsstring>
        <name>CreateVariantSequentialView</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/SequentialContainerBinder.hpp" line="302" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/SequentialContainerBinder.hpp" bodystart="302" bodyend="304" declfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" declline="39" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1aa32ccd6302ead5eab449ca21239d4404" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; Detail::IsAssociativeContainer&lt; T &gt;::value, <ref refid="class_bvr_1_1_meta_1_1_variant_associative_view" kindref="compound">VariantAssociativeView</ref> &gt;</type>
        <definition>std::enable_if_t&lt; Detail::IsAssociativeContainer&lt; T &gt;::value, VariantAssociativeView &gt; Bvr::Meta::Detail::CreateVariantAssociativeView</definition>
        <argsstring>(T &amp;&amp;val)</argsstring>
        <name>CreateVariantAssociativeView</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/AssociativeContainerBinder.hpp" line="395" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/AssociativeContainerBinder.hpp" bodystart="395" bodyend="397" declfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" declline="44" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1a44607a0eeebbc1ad96283542d7298450" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt;!Detail::IsAssociativeContainer&lt; T &gt;::value, <ref refid="class_bvr_1_1_meta_1_1_variant_associative_view" kindref="compound">VariantAssociativeView</ref> &gt;</type>
        <definition>std::enable_if_t&lt;!Detail::IsAssociativeContainer&lt; T &gt;::value, VariantAssociativeView &gt; Bvr::Meta::Detail::CreateVariantAssociativeView</definition>
        <argsstring>(T &amp;&amp;val)</argsstring>
        <name>CreateVariantAssociativeView</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>val</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/AssociativeContainerBinder.hpp" line="402" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/AssociativeContainerBinder.hpp" bodystart="402" bodyend="404" declfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" declline="48" declcolumn="5"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1a8439dae7726b57a04ca76f63702e8e2e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Tp</type>
            <defval>std::remove_cv_t&lt;T&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_copy_constructible_v&lt; Tp &gt; &amp;&amp;IsWrapper&lt; T &gt;::value, <ref refid="class_bvr_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &gt;</type>
        <definition>std::enable_if_t&lt;std::is_copy_constructible_v&lt;Tp&gt; &amp;&amp; IsWrapper&lt;T&gt;::value, Variant&gt; Bvr::Meta::Detail::GetWrappedValue</definition>
        <argsstring>(T &amp;value)</argsstring>
        <name>GetWrappedValue</name>
        <param>
          <type>T &amp;</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" line="53" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" bodystart="53" bodyend="57"/>
      </memberdef>
      <memberdef kind="function" id="_variant_policy_8hpp_1a6df44ad94959b56381459f23b559a38f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename Tp</type>
            <defval>std::remove_cv_t&lt;T&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt;!std::is_copy_constructible_v&lt; Tp &gt;||!IsWrapper&lt; T &gt;::value, <ref refid="class_bvr_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &gt;</type>
        <definition>std::enable_if_t&lt;!std::is_copy_constructible_v&lt;Tp&gt; || !IsWrapper&lt;T&gt;::value, Variant&gt; Bvr::Meta::Detail::GetWrappedValue</definition>
        <argsstring>(T &amp;)</argsstring>
        <name>GetWrappedValue</name>
        <param>
          <type>T &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" line="62" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/VariantPolicy.hpp" bodystart="62" bodyend="64"/>
      </memberdef>
      <memberdef kind="function" id="_wrapper_binder_8hpp_1ac0c821e90811149e4711a076a19f24c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto Bvr::Meta::Detail::WrappedRawAddressOf</definition>
        <argsstring>(T &amp;obj)</argsstring>
        <name>WrappedRawAddressOf</name>
        <param>
          <type>T &amp;</type>
          <declname>obj</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/WrapperBinder.hpp" line="66" column="22" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/WrapperBinder.hpp" bodystart="66" bodyend="73"/>
      </memberdef>
      <memberdef kind="function" id="_type_desc_8hpp_1a5eab46a77a37ebc820350ab093adc16c" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>TypeTraitsInfos</type>
            <declname>Trait</declname>
            <defname>Trait</defname>
          </param>
          <param>
            <type>typename StdTrait</type>
          </param>
        </templateparamlist>
        <type>constexpr TypeTraitVal</type>
        <definition>constexpr TypeTraitVal Bvr::Meta::Detail::TestTrait</definition>
        <argsstring>()</argsstring>
        <name>TestTrait</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" line="87" column="35" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" bodystart="87" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="_type_desc_8hpp_1aa017307843c0e8ea6f62351318c74c28" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>TypeTraitsInfos</type>
            <declname>Trait</declname>
            <defname>Trait</defname>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool Bvr::Meta::Detail::TestTrait</definition>
        <argsstring>(TypeData *pType)</argsstring>
        <name>TestTrait</name>
        <param>
          <type><ref refid="struct_bvr_1_1_meta_1_1_type_data" kindref="compound">TypeData</ref> *</type>
          <declname>pType</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" line="93" column="27" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" bodystart="93" bodyend="95"/>
      </memberdef>
      <memberdef kind="function" id="_type_desc_8hpp_1a973e079c6bd88105e6f2539b965260e2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename WrapperT</type>
          </param>
          <param>
            <type>typename WrappedTypeT</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void Bvr::Meta::Detail::CreateWrapper</definition>
        <argsstring>(const Argument &amp;arg, Variant &amp;out)</argsstring>
        <name>CreateWrapper</name>
        <param>
          <type>const <ref refid="class_bvr_1_1_meta_1_1_argument" kindref="compound">Argument</ref> &amp;</type>
          <declname>arg</declname>
        </param>
        <param>
          <type><ref refid="class_bvr_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &amp;</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" line="120" column="17" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" bodystart="120" bodyend="126"/>
      </memberdef>
      <memberdef kind="function" id="_type_desc_8hpp_1a0ad8b8c72dba410b67b4dec31036dc19" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename WrapperT</type>
          </param>
          <param>
            <type>typename T</type>
            <defval>WrapperBinderT&lt;WrapperT&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; IsWrapper&lt; WrapperT &gt;::value &amp;&amp;std::is_copy_constructible_v&lt; WrapperT &gt; &amp;&amp;std::is_default_constructible_v&lt; WrapperT &gt;, Interface::CreateWrapperFn &gt;</type>
        <definition>std::enable_if_t&lt;IsWrapper&lt;WrapperT&gt;::value &amp;&amp; std::is_copy_constructible_v&lt;WrapperT&gt; &amp;&amp; std::is_default_constructible_v&lt;WrapperT&gt;, Interface::CreateWrapperFn&gt; Bvr::Meta::Detail::GetCreateWrapperFn</definition>
        <argsstring>()</argsstring>
        <name>GetCreateWrapperFn</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" line="133" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" bodystart="133" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="_type_desc_8hpp_1ac0333876d007c9e81dc6bd5535c11d88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename WrapperT</type>
          </param>
          <param>
            <type>typename T</type>
            <defval>WrapperBinderT&lt;WrapperT&gt;</defval>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt;!IsWrapper&lt; WrapperT &gt;::value||!std::is_copy_constructible_v&lt; WrapperT &gt;||!std::is_default_constructible_v&lt; WrapperT &gt;, Interface::CreateWrapperFn &gt;</type>
        <definition>std::enable_if_t&lt;!IsWrapper&lt;WrapperT&gt;::value || !std::is_copy_constructible_v&lt;WrapperT&gt; || !std::is_default_constructible_v&lt;WrapperT&gt;, Interface::CreateWrapperFn&gt; Bvr::Meta::Detail::GetCreateWrapperFn</definition>
        <argsstring>()</argsstring>
        <name>GetCreateWrapperFn</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" line="142" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" bodystart="142" bodyend="144"/>
      </memberdef>
      <memberdef kind="function" id="_type_desc_8hpp_1a60c17300ec5f7d2586d39a711cf53fba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="struct_bvr_1_1_meta_1_1_type_data" kindref="compound">TypeData</ref> *</type>
        <definition>TypeData* Bvr::Meta::Detail::GetWrappedType</definition>
        <argsstring>()</argsstring>
        <name>GetWrappedType</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" line="147" column="14" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" bodystart="147" bodyend="149"/>
      </memberdef>
      <memberdef kind="function" id="_type_desc_8hpp_1acb5c1eee66a32586e849a56973da28e9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>size_t Bvr::Meta::Detail::SizeOfHelper</definition>
        <argsstring>()</argsstring>
        <name>SizeOfHelper</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" line="190" column="31" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" bodystart="190" bodyend="195"/>
      </memberdef>
      <memberdef kind="function" id="_type_desc_8hpp_1a839244f445ddcb7afe643996c33f4731" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="struct_bvr_1_1_meta_1_1_type_data" kindref="compound">TypeData</ref> *</type>
        <definition>TypeData* Bvr::Meta::Detail::GetRawTypeData</definition>
        <argsstring>()</argsstring>
        <name>GetRawTypeData</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" line="198" column="21" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeDesc.hpp" bodystart="198" bodyend="205"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1aa72a92a26bebd82ff26d16a559b95cb9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Bvr::Meta::Detail::IsWrappedEnum</definition>
        <argsstring>(const Argument &amp;from)</argsstring>
        <name>IsWrappedEnum</name>
        <param>
          <type>const <ref refid="class_bvr_1_1_meta_1_1_argument" kindref="compound">Argument</ref> &amp;</type>
          <declname>from</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="7" column="17" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="7" bodyend="15"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1ae31fa7c8f8ca2612223f0687805b5dac" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if&lt; std::is_same_v&lt; From, To &gt;, bool &gt;::type</type>
        <definition>std::enable_if&lt;std::is_same_v&lt;From, To&gt;, bool&gt;::type Bvr::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Integral casts////////////////////////////////////////////// </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="72" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="72" bodyend="75"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a31e36f681886209cb397718112af05ea" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; AreIntegrals&lt; From, To &gt;::value &amp;&amp;!std::is_signed_v&lt; From &gt; &amp;&amp;std::is_signed_v&lt; To &gt;, bool &gt;</type>
        <definition>std::enable_if_t&lt;AreIntegrals&lt;From, To&gt;::value &amp;&amp; !std::is_signed_v&lt;From&gt; &amp;&amp; std::is_signed_v&lt;To&gt;, bool&gt; Bvr::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="82" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="82" bodyend="89"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a06d2ceb9733304ca5afe22778945a4d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; AreIntegrals&lt; From, To &gt;::value &amp;&amp;std::is_signed_v&lt; From &gt; &amp;&amp;!std::is_signed_v&lt; To &gt;, bool &gt;</type>
        <definition>std::enable_if_t&lt;AreIntegrals&lt;From, To&gt;::value &amp;&amp; std::is_signed_v&lt;From&gt; &amp;&amp; !std::is_signed_v&lt;To&gt;, bool&gt; Bvr::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="96" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="96" bodyend="106"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1ad388116194327160d4878eb7dd503d87" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; AreIntegrals&lt; From, To &gt;::value &amp;&amp;std::is_signed_v&lt; From &gt; &amp;&amp;std::is_signed_v&lt; To &gt;, bool &gt;</type>
        <definition>std::enable_if_t&lt;AreIntegrals&lt;From, To&gt;::value &amp;&amp; std::is_signed_v&lt;From&gt; &amp;&amp; std::is_signed_v&lt;To&gt;, bool&gt; Bvr::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="113" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="113" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1aa21b6f9ce653719b7a567664e4ab1115" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; AreIntegrals&lt; From, To &gt;::value &amp;&amp;!std::is_signed_v&lt; From &gt; &amp;&amp;!std::is_signed_v&lt; To &gt;, bool &gt;</type>
        <definition>std::enable_if_t&lt;AreIntegrals&lt;From, To&gt;::value &amp;&amp; !std::is_signed_v&lt;From&gt; &amp;&amp; !std::is_signed_v&lt;To&gt;, bool&gt; Bvr::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="128" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="128" bodyend="134"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a08fc6e4a00f89184e3cd779e49aaf283" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_floating_point_v&lt; From &gt; &amp;&amp;std::is_integral_v&lt; To &gt; &amp;&amp;!std::is_signed_v&lt; To &gt;, bool &gt;</type>
        <definition>std::enable_if_t&lt;std::is_floating_point_v&lt;From&gt; &amp;&amp; std::is_integral_v&lt;To&gt; &amp;&amp; !std::is_signed_v&lt;To&gt;, bool&gt; Bvr::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Floating casts////////////////////////////////////////////// </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="144" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="144" bodyend="151"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1ad2b0deacbd70c972bfb924b872f46a4e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename From</type>
          </param>
          <param>
            <type>typename To</type>
          </param>
        </templateparamlist>
        <type>std::enable_if_t&lt; std::is_floating_point_v&lt; From &gt; &amp;&amp;std::is_integral_v&lt; To &gt; &amp;&amp;std::is_signed_v&lt; To &gt;, bool &gt;</type>
        <definition>std::enable_if_t&lt;std::is_floating_point_v&lt;From&gt; &amp;&amp; std::is_integral_v&lt;To&gt; &amp;&amp; std::is_signed_v&lt;To&gt;, bool&gt; Bvr::Meta::Detail::CastTo</definition>
        <argsstring>(const From &amp;from, To &amp;to)</argsstring>
        <name>CastTo</name>
        <param>
          <type>const From &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type>To &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="158" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="158" bodyend="166"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a118b43964735249e7dc1d4353bd5f32f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Bvr::Meta::Detail::ToEnumeration</definition>
        <argsstring>(std::string_view name, Argument &amp;to)</argsstring>
        <name>ToEnumeration</name>
        <param>
          <type>std::string_view</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="class_bvr_1_1_meta_1_1_argument" kindref="compound">Argument</ref> &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="170" column="17" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="170" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1adc10b646c35f883f85422bfcc1159962" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Bvr::Meta::Detail::ToEnumeration</definition>
        <argsstring>(const Variant &amp;from, Argument &amp;to)</argsstring>
        <name>ToEnumeration</name>
        <param>
          <type>const <ref refid="class_bvr_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &amp;</type>
          <declname>from</declname>
        </param>
        <param>
          <type><ref refid="class_bvr_1_1_meta_1_1_argument" kindref="compound">Argument</ref> &amp;</type>
          <declname>to</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="183" column="17" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="183" bodyend="208"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a46eeb0421b97f7230b42671697961609" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool Bvr::Meta::Detail::StringToBool</definition>
        <argsstring>(std::string src, bool *bOk)</argsstring>
        <name>StringToBool</name>
        <param>
          <type>std::string</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="1080" column="17" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="1080" bodyend="1105"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a509d05d878312cf89f3492c5bee5c2f3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int Bvr::Meta::Detail::StringToI32</definition>
        <argsstring>(const std::string &amp;src, bool *bOk)</argsstring>
        <name>StringToI32</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="1107" column="16" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="1107" bodyend="1125"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a9ea79e76c7861b9d4f6bf60bfd847a6a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::uint32_t</type>
        <definition>std::uint32_t Bvr::Meta::Detail::StringToU32</definition>
        <argsstring>(const std::string &amp;src, bool *bOk)</argsstring>
        <name>StringToU32</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="1127" column="26" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="1127" bodyend="1146"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1aa9ccfca21f46386cb7b078d2cdce56f6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::int64_t</type>
        <definition>std::int64_t Bvr::Meta::Detail::StringToI64</definition>
        <argsstring>(const std::string &amp;src, bool *bOk)</argsstring>
        <name>StringToI64</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="1148" column="25" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="1148" bodyend="1165"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a7336b2e8255782a4c1d626d9aa10da49" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>std::uint64_t</type>
        <definition>std::uint64_t Bvr::Meta::Detail::StringToU64</definition>
        <argsstring>(const std::string &amp;src, bool *bOk)</argsstring>
        <name>StringToU64</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="1167" column="26" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="1167" bodyend="1192"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1af491efd73d4a3bcce64c9935cad91666" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>float</type>
        <definition>float Bvr::Meta::Detail::StringToF32</definition>
        <argsstring>(const std::string &amp;src, bool *bOk)</argsstring>
        <name>StringToF32</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="1194" column="18" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="1194" bodyend="1212"/>
      </memberdef>
      <memberdef kind="function" id="_type_casting_8hpp_1a2c724c7c558908f35bf352ffb0b9acb4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>double</type>
        <definition>double Bvr::Meta::Detail::StringToF64</definition>
        <argsstring>(const std::string &amp;src, bool *bOk)</argsstring>
        <name>StringToF64</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>src</declname>
        </param>
        <param>
          <type>bool *</type>
          <declname>bOk</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" line="1214" column="19" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/TypeCasting.hpp" bodystart="1214" bodyend="1232"/>
      </memberdef>
      <memberdef kind="function" id="_variant_8hpp_1a2beb3b2e40e41f38439e0342b814cd89" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="struct_bvr_1_1_meta_1_1_detail_1_1_object_memory_storage" kindref="compound">ObjectMemoryStorage</ref></type>
        <definition>ObjectMemoryStorage Bvr::Meta::Detail::GetVariantObjectMemoryStorage</definition>
        <argsstring>(const Variant &amp;var)</argsstring>
        <name>GetVariantObjectMemoryStorage</name>
        <param>
          <type>const <ref refid="class_bvr_1_1_meta_1_1_variant" kindref="compound">Variant</ref> &amp;</type>
          <declname>var</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Variant.hpp" line="272" column="5" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Variant.hpp" bodystart="272" bodyend="274" declfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/ObjectMemoryStorage.hpp" declline="25" declcolumn="21"/>
      </memberdef>
      <memberdef kind="function" id="_method_8hpp_1aa494898e9b1a9a6dba266e7145469b01" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>typename TArgs</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Bvr::Meta::Detail::GetTypes</definition>
        <argsstring>(std::span&lt; Type &gt; list)</argsstring>
        <name>GetTypes</name>
        <param>
          <type>std::span&lt; <ref refid="class_bvr_1_1_meta_1_1_type" kindref="compound">Type</ref> &gt;</type>
          <declname>list</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Method.hpp" line="24" column="17" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Method.hpp" bodystart="24" bodyend="32"/>
      </memberdef>
      <memberdef kind="function" id="_method_8hpp_1a12983b54e788fe7aa18066d64c0ed51f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
          <param>
            <type>typename TArgs</type>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool Bvr::Meta::Detail::GetArgs</definition>
        <argsstring>(TArgs &amp;args, const std::span&lt; Argument const &gt; &amp;list)</argsstring>
        <name>GetArgs</name>
        <param>
          <type>TArgs &amp;</type>
          <declname>args</declname>
        </param>
        <param>
          <type>const std::span&lt; <ref refid="class_bvr_1_1_meta_1_1_argument" kindref="compound">Argument</ref> const &gt; &amp;</type>
          <declname>list</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Method.hpp" line="35" column="17" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Method.hpp" bodystart="35" bodyend="47"/>
      </memberdef>
      <memberdef kind="function" id="_utils_8hpp_1a9b22bb9845e8131494fc4147df724718" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>RawAddressofReturnTypeT&lt; T &gt;</type>
        <definition>static RawAddressofReturnTypeT&lt;T&gt; Bvr::Meta::Detail::RawAddressOf</definition>
        <argsstring>(T &amp;data)</argsstring>
        <name>RawAddressOf</name>
        <param>
          <type>T &amp;</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" line="82" column="43" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" bodystart="82" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="_utils_8hpp_1a9c511abe9e8dcf5cf3105e015d489118" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>RawAddressofReturnTypeT&lt; T &gt;</type>
        <definition>static RawAddressofReturnTypeT&lt;T&gt; Bvr::Meta::Detail::RawAddressOf</definition>
        <argsstring>(T *data)</argsstring>
        <name>RawAddressOf</name>
        <param>
          <type>T *</type>
          <declname>data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" line="86" column="43" bodyfile="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Utils.hpp" bodystart="86" bodyend="88"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/runner/work/BeaverEngine/BeaverEngine/Beaver/Code/BvrCommon/Meta/Type.hpp" line="15" column="1"/>
  </compounddef>
</doxygen>
